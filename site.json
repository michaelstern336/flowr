{"title":"flowr","githubRepo":"monojack/flowr","googleAnalytics":"UA-37033501-5","index":{"title":"Home","description":"Simple and declarative flow control components for React apps.","content":" flowr ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/flowr/./","children":{"docs":{"children":{"getting-started":{"title":"Getting started","description":"Get started with Flowr","layout":"guide","icon":"arrow-right-rod","weight":1,"content":" {$page.description} Installation To add flowr to your application dependencies you just need to run: npm install flowr -S This will download flowr into your node_modules folder and then you can import any flowr component into your modules. import { Maybe, Either, Await } from 'flowr'; // ... Flowr is tree-shaking friendly. As long as you are using ES6 modules, your bundle will contain only the required flowr components. Read more about tree shaking There are two categories of Components available: Conditionals and Schedulers Conditionals | Name | Props | Description | | ---------------------- | :----- | :---------------------------------------------------------------------------------------------------- | | Maybe | when | Renders it's children only if when is true | | Either | when | If when is true it renders the first child, otherwise it renders the second | | Flip | when | Flips the order of the first two children | | Reverse | when | Reverses the order of all its children | | Order | sort | Re-orders the children in the order provided through sort | | One | at | Renders only the child at the specified index | | Some | at | Renders only the children at the specified indices if they exist | | Constant | `` | Will render *only once**, never updating the state of it's children (shouldComponentUpdate - false) | | Pure | `` | Will re-render *only** when the passed props have changed (PureComponent) | | Just | * | Just renders it's children, nothing special, good for dynamic rendering | | Nothing | * | Renders nothing | Schedulers | Name | Props | Description | | ---------------------- | :------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | Await | for, tap, onPromise | Renders it's children when and only if the provided promise resolves. When used with a render prop, it will always apply the promise result (err, res) to the callback. It also accepts a function that returns a Promise | | Stream | `` | Render-prop component that enables working with *props streams** | | Debounce | time, immediate | Renders it's children only after a certain amount of time has passed since the previous render. | | Delay | time | Renders it's children only after a certain amount of time has passed | | Throttle | time | Renders it's children at most once in the specified time interval. | [maybe]: conditionals/Maybe.html [either]: conditionals/Either.html [flip]: conditionals/Flip.html [reverse]: conditionals/Reverse.html [order]: conditionals/Order.html [one]: conditionals/One.html [some]: conditionals/Some.html [constant]: conditionals/Constant.html [pure]: conditionals/Pure.html [just]: conditionals/Just.html [nothing]: conditionals/Nothing.html [await]: schedulers/Await.html [stream]: schedulers/Stream.html [debounce]: schedulers/Debounce.html [delay]: schedulers/Delay.html [throttle]: schedulers/Throttle.html ","srcFilePath":"src/pages/docs/getting-started.md","id":"getting-started","location":"/docs/getting-started.html","url":"/flowr/docs/getting-started.html"},"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/flowr/docs/search.html"},"conditionals":{"children":{"Constant":{"title":"Constant","layout":"guide","weight":8,"content":" import { Constant } from 'flowr'; Constant will render it's children only once, with their initial state, effectively preventing any updates. // ... state = { count: 0 } increment = () = { this.setState(({count}) = ({ count: count + 1 })) } render() { return ( {this.state.count} ) } // Constant's children will never be updated // Will render: 0 Props | Name | Type | Default | Description | | ---- | :--- | :------ | :---------- | --- ","srcFilePath":"src/pages/docs/conditionals/Constant.md","id":"Constant","location":"/docs/conditionals/Constant.html","url":"/flowr/docs/conditionals/Constant.html"},"Either":{"title":"Either","layout":"guide","weight":2,"content":" import { Either } from 'flowr'; An Either is like a regular if/else statement When the predicate is true, it will render the first child, otherwise it will render the second. Either will only consider the first two children, everything else will be ignored. You can use a any other wrapping element or a Fragment to get around this limitation. A B // for predicate === true: A // for predicate === false: B Props | Name | Type | Default | Description | | -------- | :--- | :------ | :---------------------------------------------------------------------------------- | | when | bool | true | When this is true, render the first child element. If false, render the second. | --- See also Maybe [maybe]: Maybe.html ","srcFilePath":"src/pages/docs/conditionals/Either.md","id":"Either","location":"/docs/conditionals/Either.html","url":"/flowr/docs/conditionals/Either.html"},"Flip":{"title":"Flip","layout":"guide","weight":3,"content":" import { Flip } from 'flowr'; Flip will flip the order of it's first two children when the predicate is true or none provided. Flip only flips the first two children. See Reverse or Order if you want to reverse the order of all children or arrange them in a specific order. A B C // for predicate === true: B A C // for predicate === false: A B C Props | Name | Type | Default | Description | | -------- | :--- | :------ | :---------------------------------------------- | | when | bool | true | If true, do the flip. If false, do nothing. | --- See also Reverse, Order [reverse]: Reverse.html [order]: Order.html ","srcFilePath":"src/pages/docs/conditionals/Flip.md","id":"Flip","location":"/docs/conditionals/Flip.html","url":"/flowr/docs/conditionals/Flip.html"},"Just":{"title":"Just","layout":"guide","weight":8,"content":" import { Just } from 'flowr'; Just has no special behaviour, it just renders it's children without any changes. Just is useful when you need to dynamically create a controlled render. // ... render() { // If we have a predicate defined, we want to render the span // only when that predicate is true. If not, just render it. const Wrapper = this.props.predicate ? Maybe : Just return ( // Just will ignore the props Hello, world! ) } The above snippet is just for the sake of example. You would achieve the same outcome by using just a Maybe: // ... Hello, world! Props | Name | Type | Default | Description | | ---- | :--- | :------ | :---------- | --- See also Nothing [nothing]: Nothing.html [maybe]: Maybe.html ","srcFilePath":"src/pages/docs/conditionals/Just.md","id":"Just","location":"/docs/conditionals/Just.html","url":"/flowr/docs/conditionals/Just.html"},"Maybe":{"title":"Maybe","layout":"guide","weight":1,"content":" import { Maybe } from 'flowr'; A Maybe is the basic implementation of a conditional render. If when prop is true, it will render all it's children, otherwise it will render nothing. Hello, world! Try out Flowr // for predicate === true: Hello, world! Try out Flowr // for predicate === false: Props | Name | Type | Default | Description | | -------- | :--- | :------ | :------------------------------------------------------------------------------ | | when | bool | false | When this is true, render all the child elements. If false, render nothing. | --- See also Either [either]: Either.html ","srcFilePath":"src/pages/docs/conditionals/Maybe.md","id":"Maybe","location":"/docs/conditionals/Maybe.html","url":"/flowr/docs/conditionals/Maybe.html"},"Nothing":{"title":"Nothing","layout":"guide","weight":9,"content":" import { Nothing } from 'flowr'; Same as Just, a Nothing has no special behavior but is useful when you need to dynamically create a controlled render. // ... render() { // Our API request may return data and/or error. // If we get both, display the data along with a notification about the error // only when the error has a message. const { data, error = {} } = this.props.response const Message = error.message ? Notification : Nothing return ( JSON.stringify(data) {error.message} ) } Props | Name | Type | Default | Description | | ---- | :--- | :------ | :---------- | --- See also Just [just]: Just.html ","srcFilePath":"src/pages/docs/conditionals/Nothing.md","id":"Nothing","location":"/docs/conditionals/Nothing.html","url":"/flowr/docs/conditionals/Nothing.html"},"One":{"title":"One","layout":"guide","weight":6,"content":" import { One } from 'flowr'; One will render only the child located at the specified index. A B C // Will render: C If the at prop is not provided, nothing will be rendered. A B C // Will render: ","srcFilePath":"src/pages/docs/conditionals/One.md","id":"One","location":"/docs/conditionals/One.html","url":"/flowr/docs/conditionals/One.html"},"Order":{"title":"Order","layout":"guide","weight":5,"content":" import { Order } from 'flowr'; Order will rearrange the children based on a specified order. The sort prop will take an array of indices that map to the children indices. The children order will be the same as the position of their index inside the array. If the sort prop is not provided, the children order will remain unchanged. A B C // will render: B C A Any index that will not have a corresponding child will be ignored. Likewise, any index that is left out will result in that child not being rendered. // sort={[1, 2, 0, 3]} // will render: B C A // sort={[2, 0]} // will render: C A Props | Name | Type | Default | Description | | -------- | :---- | :------ | :------------------------------------------------------------------------------------------------- | | sort | array | _-_ | An array containing the children indices sorted by the order in which we want them to be rendered. | --- See also Flip, Reverse [flip]: Flip.html [reverse]: Reverse.html ","srcFilePath":"src/pages/docs/conditionals/Order.md","id":"Order","location":"/docs/conditionals/Order.html","url":"/flowr/docs/conditionals/Order.html"},"Pure":{"title":"Pure","layout":"guide","weight":10,"content":" import { Pure } from 'flowr'; Pure wraps it's children in a component that implements shouldComponentUpdate. Whatever props you provide to Pure will be compared for shallow equality and determine if the component should update. None of the props will be passed down to the children. Pure will ignore the children when comparing props // ... state = { count: 0, label: 'started at' } componentDidMount() { setInterval(this.increment, 1000) } increment = () = { this.setState(({ count }) = ({ count: count + 1 })) } render() { const { count, label } = this.state return ( {label}: {count} ) } In the above example, we are incrementing the count and updating state with the new value each second. Because Pure only \"listens\" for the label, it won't update unless we actually change state.label. When we do that, it will update the children with the new label and count. Props | Name | Type | Default | Description | | ---- | :--- | :------ | :--------------------------------------------------------------------------------- | | \\* | \\* | \\* | Accepts any props, the scope is to just compare them in order to determine updates | --- ","srcFilePath":"src/pages/docs/conditionals/Pure.md","id":"Pure","location":"/docs/conditionals/Pure.html","url":"/flowr/docs/conditionals/Pure.html"},"Reverse":{"title":"Reverse","layout":"guide","weight":4,"content":" import { Reverse } from 'flowr'; Reverse will reverse the order of all it's children when the predicate is true or none provided. A B C // for predicate === true C B A // for predicate === false: A B C Props | Name | Type | Default | Description | | -------- | :--- | :------ | :---------------------------------------------------- | | when | bool | true | If true, reverse the order. If false, do nothing. | --- See also Flip, Order [flip]: Flip.html [order]: Order.html ","srcFilePath":"src/pages/docs/conditionals/Reverse.md","id":"Reverse","location":"/docs/conditionals/Reverse.html","url":"/flowr/docs/conditionals/Reverse.html"},"Some":{"title":"Some","layout":"guide","weight":7,"content":" import { Some } from 'flowr'; Some will render only the children located at the specified indices. Some will not change the children order. See Order if you are looking to render specific children in a specific order. A B C // Will render: A C If the at prop is not provided, nothing will be rendered. A B C // Will render: ","srcFilePath":"src/pages/docs/conditionals/Some.md","id":"Some","location":"/docs/conditionals/Some.html","url":"/flowr/docs/conditionals/Some.html"}},"title":"Conditionals","description":"A set of components to achieve conditional constructs","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} | Name | Props | Description | | ---------------------- | :----- | :---------------------------------------------------------------------------------------------------- | | Maybe | when | Renders it's children only if when is true | | Either | when | If when is true it renders the first child, otherwise it renders the second | | Flip | when | Flips the order of the first two children | | Reverse | when | Reverses the order of all its children | | Order | sort | Re-orders the children in the order provided through sort | | One | at | Renders only the child at the specified index | | Some | at | Renders only the children at the specified indices if they exist | | Constant | `` | Will render *only once**, never updating the state of it's children (shouldComponentUpdate - false) | | Pure | `` | Will re-render *only** when the passed props have changed (PureComponent) | | Just | * | Just renders it's children, nothing special, good for dynamic rendering | | Nothing | * | Renders nothing | [maybe]: Maybe.html [either]: Either.html [flip]: Flip.html [reverse]: Reverse.html [order]: Order.html [one]: One.html [some]: Some.html [constant]: Constant.html [pure]: Pure.html [just]: Just.html [nothing]: Nothing.html ","srcFilePath":"src/pages/docs/conditionals/index.md","id":"conditionals","location":"/docs/conditionals/","url":"/flowr/docs/conditionals/","childIds":["Maybe","Either","Flip","Reverse","Order","One","Some","Constant","Just","Nothing","Pure"]},"schedulers":{"children":{"Await":{"title":"Await","layout":"guide","weight":1,"content":" import { Await } from 'flowr'; \\ \\ Await will render it's children when and only if the provided promise resolves. When used with a render prop, it will always apply the promise result (err, res) to the callback. Hello, world! // resolved: Hello, world! // rejected: \\ \\ Await can also be used with a render prop. The render callback will take two arguments: error and response. {(err, res) = ( {res.data.map(item = {item})} Sorry, we cannot fetch the results right now. Try again later )} \\ \\ You can also provide a Promise returning function to keep things lazy and only evaluate the promise when the component is constructed. // ... render() { const { shouldFetch, url } = this.props return ( fetch(url)} { (err, res) = ( JSON.stringify(res.data) ) } ) } If you are providing a function, a new promise will be returned everytime you are adding/removing the element to/from the DOM. This will initiate a new request each time. There are ways around this, like keeping track of the promise in the parent component and pass that if it's defined. You can get a reference to the promise through the onPromise callback prop. // ... promise = null toggleFriends = (e) = { this.setState({ showFriends: e.target.checked }) } render() { const { showFriends } = this.state const { url } = this.state return ( fetch(url)} onPromise={(promise) = (this.promise = promise)} { (err, res) = ( // display list of friends, or not... ) } ) } If you don't specify a valid for prop, everything will shortcircuit and the children will be rendered immediately, as there is nothing to \"wait for\". Props | Name | Type | Default | Description | | ------------- | :--------------------------------------- | :------ | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | for | oneOfType([ instanceOf(Promise), func ]) | _-_ | The promise we need to wait for, or a function that will return one which will be evaluated lazily, in the component's constructor | | tap | func | _-_ | Takes an error and a response argument and is called when the promise is fulfilled. Use this to perform side-effects or just for debugging purposes. | | onPromise | func | _-_ | Takes a single argument that will be the promise returned from the function passed through the for prop. Useful for keeping track of the first promise. Will not be called if we already pass a Promise to the for prop. | --- ","srcFilePath":"src/pages/docs/schedulers/Await.md","id":"Await","location":"/docs/schedulers/Await.html","url":"/flowr/docs/schedulers/Await.html"},"Debounce":{"title":"Debounce","layout":"guide","weight":4,"content":" import { Debounce } from 'flowr'; \\ \\ Debounce will render it's children only after a certain amount of time has passed since the previous render. // ... state = { count: 0 } componentDidMount() { // start an interval that will increment state.count up to 5 and then stop. this.interval = setInterval(() = { if (this.state.count === 5) { return clearInterval(this.interval) } this.setState(state = ({ count: state.count + 1 })) }, 300) } render() { return ( {this.state.count} ) } In the above example, if skipFirst is true the span containing 5** will be rendered after 500ms have passed since the last state update. If skipFirst is false, the starting **0 will also be rendered. \\ \\ Debounce becomes very useful when you want to prevent some actions or events from firing multiple times in a short timeframe. Here's an example of how you'd implement a debounced auto suggest input field using some of the components provided by Flowr: onChange = (e) = { this.setState({ suggestionsUrl: https://exampleapi.com/suggestions?query=${e.target.value} }) } render() { const { suggestionsUrl } = this.state return ( fetch(suggestionsUrl)} { (err, res) = ( { res.data.map(suggestion = {suggestion.label}) } ) } ) } Props | Name | Type | Default | Description | | ------------- | :----- | :------ | :----------------------------------------------------------------------------------------------------------------------- | | time | number | _-_ | The amount of time in ms that we need to debounce the render for | | immediate | bool | false | When set to true it will start debouncing as soon as it mounts, when false it will let the first render pass through | --- See also Throttle [throttle]: Throttle.html ","srcFilePath":"src/pages/docs/schedulers/Debounce.md","id":"Debounce","location":"/docs/schedulers/Debounce.html","url":"/flowr/docs/schedulers/Debounce.html"},"Delay":{"title":"Delay","layout":"guide","weight":3,"content":" import { Delay } from 'flowr'; \\ \\ Delay will render it's children only after a certain amount of time has passed. // ... {this.state.count} In the above example if showFirst is true the first render will be displayed: 0 and after 2 seconds, it renders the last state updates, skipping the ones inbetween: 5 \\ \\ Delay becomes very useful when you want to prevent some actions or events from firing multiple times in a short timeframe. Here's an example of how you'd implement a debounced auto suggest input field using some of the components provided by Flowr: onChange = (e) = { this.setState({ suggestionsUrl: https://exampleapi.com/suggestions?query=${e.target.value} }) } render() { const { suggestionsUrl } = this.state return ( fetch(suggestionsUrl)} { (err, res) = ( { res.data.map(suggestion = {suggestion.label}) } ) } ) } Props | Name | Type | Default | Description | | ------------- | :----- | :------ | :----------------------------------------------------------------------------------------------------------------------- | | time | number | _-_ | The amount of time in ms that we need to debounce the render for | | immediate | bool | false | When set to true it will start debouncing as soon as it mounts, when false it will let the first render pass through | --- See also Throttle [throttle]: Throttle.html ","srcFilePath":"src/pages/docs/schedulers/Delay.md","id":"Delay","location":"/docs/schedulers/Delay.html","url":"/flowr/docs/schedulers/Delay.html"},"Stream":{"title":"Stream","layout":"guide","props":[],"weight":2,"content":" import { Stream } from 'flowr'; \\ \\ Stream is a really handy render prop component that allows you to work with props streams. The render callback takes a single argument (the props stream) and should return a stream of \"renders\". \\ The props stream is a simple Observable with only a map operator. You can convert it into a more powerful implementation by just \"lifting\" it into the type of your favourite library. \\ Below is a simple implementation of a counter that starts from 0** and ticks every **1000ms, using rxjs v5 (mind the imports) import { from } from 'rxjs/observable/from' import { interval } from 'rxjs/observable/interval' { props$ = from(props$) .switchMap( props = interval(props.time) .map(count = {props.start + count}) ) } { /* ----------0---------1---------2---------3... */} Props | Name | Type | Default | Description | | ---- | :--- | :------ | :------------------------------------------------------ | | \\* | \\* | \\* | Accepts any props and will pipe them through the stream | --- ","srcFilePath":"src/pages/docs/schedulers/Stream.md","id":"Stream","location":"/docs/schedulers/Stream.html","url":"/flowr/docs/schedulers/Stream.html"},"Throttle":{"title":"Throttle","layout":"guide","weight":5,"content":" import { Throttle } from 'flowr'; \\ \\ Throttle will render it's children at most once in the specified time interval. // ... state = { count: 0 } componentDidMount() { // start an interval that will increment state.count up to 9 and then stop. this.interval = setInterval(() = { if (this.state.count === 9) { return clearInterval(this.interval) } this.setState(state = ({ count: state.count + 1 })) }, 300) } render() { return ( {this.state.count} ) } In the above example Throttle will render the first state and after that the most recent update once every second. If no update occurred since the last render, throttling will be paused so we don't waste renders and when a new update comes, it will render that and start sampling again. { /* 0---------3---------6---------9 */ } Props | Name | Type | Default | Description | | -------- | :----- | :------ | :----------------------------------------------------------- | | time | number | _-_ | The amount of time in ms that we need to throttle the render | --- See also Debounce [debounce]: Debounce.html ","srcFilePath":"src/pages/docs/schedulers/Throttle.md","id":"Throttle","location":"/docs/schedulers/Throttle.html","url":"/flowr/docs/schedulers/Throttle.html"}},"title":"Schedulers","description":"A set of components that help scheduling renders","layout":"guide","icon":"code-file","weight":3,"content":" {$page.description} | Name | Props | Description | | ---------------------- | :------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | | Await | for, tap, onPromise | Renders it's children when and only if the provided promise resolves. When used with a render prop, it will always apply the promise result (err, res) to the callback. It also accepts a function that returns a Promise | | Stream | `` | Render-prop component that enables working with *props streams** | | Debounce | time, immediate | Renders it's children only after a certain amount of time has passed since the previous render. | | Delay | time | Renders it's children only after a certain amount of time has passed | | Throttle | time | Renders it's children at most once in the specified time interval. | [await]: Await.html [stream]: Stream.html [debounce]: Debounce.html [delay]: Delay.html [throttle]: Throttle.html ","srcFilePath":"src/pages/docs/schedulers/index.md","id":"schedulers","location":"/docs/schedulers/","url":"/flowr/docs/schedulers/","childIds":["Await","Stream","Delay","Debounce","Throttle"]}},"title":"Docs","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/flowr/docs/","childIds":["getting-started","conditionals","schedulers","search"]},"examples":{"title":"Examples","description":"Examples of common features, built with flowr components.","content":" Examples work in progress... ","srcFilePath":"src/pages/examples/index.soy","id":"examples","location":"/examples/","url":"/flowr/examples/"}},"childIds":["docs","examples"]},"basePath":"/flowr"}